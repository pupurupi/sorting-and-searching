**Определение алгоритмов:**

Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

1. Нахождение min и max: O(n) + O(n) = O(n)
2. Создание корзин: O(k), где k = количество корзин
k = (max_val - min_val) // bucket_size + 1

3. Распределение по корзинам: O(n)
Каждый элемент обрабатывается за O(1)

4. Сортировка корзин:
Это самая критичная часть! Сложность зависит от распределения данных.

Худший случай (Worst Case): O(n²)
  Когда все элементы попадают в одну корзину

  insertion_sort работает за O(n²)

  Итог: O(n²)

Лучший случай (Best Case): O(n)
  Когда элементы равномерно распределены по корзинам

  Каждая корзина содержит примерно n/k элементов

  Сортировка каждой корзины: O((n/k)²)

  Всего k корзин: O(k × (n/k)²) = O(n²/k)

  При оптимальном k ≈ n: O(n)

Средний случай (Average Case): O(n + n²/k + k)
При равномерном распределении

5. Объединение корзин: O(n)


Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

Количество сравнений: O(n²)
Поиск максимума: n + (n-1) + ... + 2 = O(n²) сравнений

Количество переворотов: O(n)
Максимум 2 переворота на итерацию: 2 × n = O(n) переворотов

Количество обменов: O(n²)
Каждый переворот k элементов: k/2 обменов

В сумме: O(n²) обменов

Анализ случаев:
Лучший случай: O(n²)
Уже отсортированный массив

Все равно ищем максимумы: O(n²) сравнений

Худший случай: O(n²)
Обратно отсортированный массив

Максимум переворотов

Средний случай: O(n²)
При любом распределении

Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году.

1. Инициализация: O(n + n×m)
max(arr): O(n)

Создание матрицы n×m: O(n × m)

2. Размещение бусин: O(S) где S = сумма элементов

for i in range(n):              # O(n) итераций
    for j in range(arr[i]):     # O(arr[i]) итераций

3. Процесс "падения": O(n × m)

4. Итоговая временная сложность:
O(n × m + S)

Где:

n = количество элементов

m = максимальное значение

S = сумма всех элементов

Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

1. Фаза прыжков: O(√n)

   Количество прыжков: n / √n = O(√n)

2. Фаза линейного поиска: O(√n)

   Размер блока: O(√n) элементов

Итоговая временная сложность: O(√n)

Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

1. Экспоненциальная фаза: O(log n)

   Количество итераций: log₂(n)

2. Бинарный поиск: O(log n)

   Размер диапазона: от i/2 до min(i, n) = O(n) элементов

   Бинарный поиск: O(log(размер_диапазона)) = O(log₂ n)

Итоговая временная сложность:O(log₂ n)

Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).

1. Деление диапазона: O(1) за итерацию

2.   Проверка элементов: O(1) за итерацию

3. Сужение диапазона: O(1) за итерацию
Диапазон уменьшается в 3 раза на каждой итерации

Итоговая временная сложность:
O(log₃n)
